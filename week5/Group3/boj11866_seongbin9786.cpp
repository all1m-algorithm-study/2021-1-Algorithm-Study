#include <iostream>
#include <vector>

/*
    [Silver 4]
    요세푸스 문제 0

    요세푸스 문제는 다음과 같다.

    1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고,
    양의 정수 K(K ≤ N)가 주어진다.

    이제 순서대로 K번째 사람을 제거한다.
    한 사람이 제거되면 남은 사람들로 이루어진 [원을 따라] 이 과정을 계속해 나간다.
    이 과정은 N명의 사람이 [모두 제거될 때까지 계속]된다.
    원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다.
    예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.

    N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.

    첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 1,000)

    예제와 같이 요세푸스 순열을 출력한다.

    7, 3 => <3, 6, 2, 7, 5, 1, 4>
*/

using namespace std;

int main()
{
    /*
    List 로 쉽게 풀 수 있지 않을까? 생각했는데,
        - O(N*K) 안에 풀 수 있을 것이다. (K번 이동을 N번 수행하기 때문.)
        - K <= N <= 1,000 이기 때문에, 최대 1,000,000 회의 연산밖에 안 되며 제한 시간은 2초이므로 충분하다.
        - 다른 계열(?) 문제들은 더 작은 시간과 공간 복잡도를 요구하는데 단순한 탐색이 아닌 계산 등으로 해결하는 듯하다.

    풀이 방법: 

    [1]. 정적 배열을 모듈러로 돌면서 flag로 표시하고 무시하는 방법
        (구현하기 귀찮다.)
        1. pop 대상인 원소에 대해 범위 이상의 숫자를 할당해 flag로 활용하는 법 (ex) 1001
        2. pop 대상인 원소에 대해 flag 배열을 따로 사용하는 법 (ex) bool popped[N];

    [2]. Circular Linked List 를 그냥 k번 순회하면서 Pop 하는 방법
        - 최초 생성 시간 복잡도: O(N)
        - erase() 의 시간 복잡도: O(1)
        - K번 순회의 시간 복잡도: O(K)
        - K번 순회, N번 반복: O(N * K)
        - O(N * K)

    [3]. 동적 배열을 모듈러로 돌면서 매번 pop 하는 법 (C++에서는 vector 사용)
        - erase() 의 시간 복잡도: 앞으로 원소를 하나씩 복사하는 형태라면 O(N)
        - size() 의 시간 복잡도: O(1)
        - O(N * N) = O(N^2)
    */

    int N, K;
    int i, r = 0;
    cin >> N >> K;
    vector<int> arr;
    for (i = 1; i <= N; i++)
        arr.push_back(i);
    
    cout << "<";

    // 2. 순회
    while (arr.size() > 1)
    {
        /*
        아래 식의 의미
            + r = 기존 idx 의미
            + K = 다음 idx 의미
            - 1 = 원소의 값은 1부터 시작하고 arr[1] != 1 이므로, arr[0]으로 만들어 주는 역할
        */
        r = (r + K - 1) % arr.size();
        cout << arr[r] << ", ";
        arr.erase(arr.begin() + r);
    }
    cout << arr[0] << ">\n";
    return 0;
}
